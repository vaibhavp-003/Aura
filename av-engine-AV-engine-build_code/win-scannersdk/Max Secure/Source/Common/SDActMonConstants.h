#include <dontuse.h>

#define SDACTMON_DEFAULT_REQUEST_COUNT      1
#define SDACTMON_DEFAULT_THREAD_COUNT       15
#define SDACTMON_MAX_THREAD_COUNT           64
#define SDACTMON_READ_BUFFER_SIZE			512

const static int IOCTL_PAUSE_PROTECTION		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8001, METHOD_NEITHER, FILE_ANY_ACCESS);
const static int IOCTL_BLOCK_USB_DRIVE		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8002, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_UNBLOCK_USB_DRIVE	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8003, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_DISCONNECT_USB_DRIVE	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8004, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_RESUME_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8005, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_REGISTER_PROCESSID	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8006, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_IEXPLORE_DATA		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8007, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_COPY_FILE			= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8008, METHOD_BUFFERED, FILE_ANY_ACCESS);


const static int IOCTL_USB_TOTAL_BLOCK		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8009, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_USB_WRITE_BLOCK		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8010, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_USB_EXECUTE_BLOCK	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8011, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_USB_READ_BLOCK		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8012, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_USB_ACTIVITY_LOG		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8015, METHOD_BUFFERED, FILE_ANY_ACCESS);
const static int IOCTL_DLP_ACTIVITY_LOG		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8018, METHOD_BUFFERED, FILE_ANY_ACCESS);



const static int IOCTL_PAUSE_CRYPT_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8013, METHOD_NEITHER, FILE_ANY_ACCESS);
const static int IOCTL_RESUME_CRYPT_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8014, METHOD_IN_DIRECT, FILE_ANY_ACCESS);

const static int IOCTL_PAUSE_NETWORK_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8016, METHOD_NEITHER, FILE_ANY_ACCESS);
const static int IOCTL_RESUME_NETWORK_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8017, METHOD_IN_DIRECT, FILE_ANY_ACCESS);

const static int IOCTL_CDDVD_BLOCK_PROTECTION	= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8019, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_FIM_MON		= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8020, METHOD_BUFFERED, FILE_ANY_ACCESS);

const static int IOCTL_START_LOGGING			= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x80050, METHOD_IN_DIRECT, FILE_ANY_ACCESS);
const static int IOCTL_STOP_LOGGING			= CTL_CODE (FILE_DEVICE_UNKNOWN, 0x80051, METHOD_IN_DIRECT, FILE_ANY_ACCESS);



#ifndef LPVOID
#define LPVOID void*
#endif

const PWSTR SDActMonPortName = L"\\SDActMonPort";

#pragma pack(1)
typedef struct _SDACTMON_NOTIFICATION
{
	HANDLE ProcessID;
    ULONG Reserved_1;			       
	ULONG TypeOfCall;
    ULONG Reserved_2;			       
	ULONG IsIgnored;
    ULONG Reserved_3;			       

	ULONG TypeOfReplication;
    UCHAR ProcessName[SDACTMON_READ_BUFFER_SIZE];
    UCHAR Accessed_1[SDACTMON_READ_BUFFER_SIZE];
    UCHAR Accessed_2[SDACTMON_READ_BUFFER_SIZE];
} SDACTMON_NOTIFICATION, *PSDACTMON_NOTIFICATION;

typedef struct _SDACTMON_REPLY
{
    BOOLEAN SafeToOpen;
} SDACTMON_REPLY, *PSDACTMON_REPLY;

typedef struct _SDACTMON_REPLY_MESSAGE
{
    FILTER_REPLY_HEADER ReplyHeader;
    SDACTMON_REPLY Reply;
} SDACTMON_REPLY_MESSAGE, *PSDACTMON_REPLY_MESSAGE;

typedef struct _SDACTMON_THREAD_CONTEXT 
{
    HANDLE Port;
    HANDLE Completion;
	LPVOID pThis;
} SDACTMON_THREAD_CONTEXT, *PSDACTMON_THREAD_CONTEXT;
#pragma pack()

#define  EXECUTE_RIGHTS (SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE | FILE_READ_DATA)

const ULONG CALL_TYPE_UNKNOWN			= 0;
const ULONG CALL_TYPE_F_EXECUTE			= 1;
const ULONG CALL_TYPE_F_CREATE			= 2;
const ULONG CALL_TYPE_F_OPEN			= 3;
const ULONG CALL_TYPE_F_DELETE			= 4;
const ULONG CALL_TYPE_F_RENAME			= 5;
const ULONG CALL_TYPE_R_CREATE			= 6;
const ULONG CALL_TYPE_R_OPEN			= 7;
const ULONG CALL_TYPE_R_DELETE			= 8;
const ULONG CALL_TYPE_R_RENAME			= 9;
const ULONG CALL_TYPE_R_SETVAL			= 10;
const ULONG CALL_TYPE_R_DELETEVAL		= 11;
const ULONG CALL_TYPE_D_CREATE			= 12;
const ULONG CALL_TYPE_F_NEW_FILE		= 13;
const ULONG CALL_TYPE_F_NEW_SYS_FILE	= 14;
const ULONG CALL_TYPE_F_REN_SYS_FILE	= 15;
const ULONG CALL_TYPE_F_DEL_SYS_FILE	= 16;
const ULONG CALL_TYPE_F_MOD_SYS_FILE	= 17;
const ULONG CALL_TYPE_F_KIDO_FILE		= 18;
const ULONG CALL_TYPE_F_REPLICATING		= 19;
const ULONG CALL_TYPE_F_R_BLOCK			= 20;
const ULONG CALL_TYPE_C_CREATE			= 21;
const ULONG CALL_TYPE_U_CREATE			= 22;
const ULONG CALL_TYPE_U_WRITE			= 23;
const ULONG CALL_TYPE_U_EXECUTE			= 24;
const ULONG CALL_TYPE_N_CREATE			= 25;
const ULONG CALL_TYPE_FIM_DELETE		= 26;
const ULONG CALL_TYPE_FIM_RENAME		= 27;
const ULONG CALL_TYPE_FIM_MODIFY		= 28;
const ULONG CALL_TYPE_FIM_CREATE		= 29;