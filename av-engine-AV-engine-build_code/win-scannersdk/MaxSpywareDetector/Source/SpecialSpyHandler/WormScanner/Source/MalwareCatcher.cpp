 /*====================================================================================
   FILE				: MalwareCatcher.cpp
   ABSTRACT			: This class is used for scanning and qurantining Malware catcher
   DOCUMENTS		: SpecialSpyHandler_DesignDoc.doc
   AUTHOR			: Shwtea Mulay
   COMPANY			: Aura 
   COPYRIGHT NOTICE : (C) Aura
      				  Created as an unpublished copyright work.  All rights reserved.
     				  This document and the information it contains is confidential and
      				  proprietary to Aura.  Hence, it may not be 
      				  used, copied, reproduced, transmitted, or stored in any form or by any 
      				  means, electronic, recording, photocopying, mechanical or otherwise, 
      				  without the prior written permission of Aura
   CREATION DATE	: 30/05/2009
   NOTE				:
   VERSION HISTORY	: 2.5.0.79
========================================================================================*/

#include "pch.h"
#include "MalwareCatcher.h"
#include "ExecuteProcess.h"
#include "PathExpander.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*-------------------------------------------------------------------------------------
	Function		: ScanSplSpy
	In Parameters	: bool , CFileSignatureDB
	Out Parameters	: bool
	Purpose			: check for Malware Catcher
	Author			: Shweta Mulay
	Description		: Validated if the run entry or lnk file is related to malware catcher.
--------------------------------------------------------------------------------------*/
bool CMalwareCatcherWorm ::ScanSplSpy ( bool bToDelete, CFileSignatureDb *pFileSigMan)
{
	try
	{
		CString csData, csSid;
		CFileVersionInfo objFVI;
		CExecuteProcess objExecProc;
		m_pFileSigMan = pFileSigMan;
		CString csFileNM, csFolder;
		
		if(IsStopScanningSignaled())
			return ( false ) ;
		
		csSid = objExecProc.GetCurrentUserSid() ;

		if ( m_objReg.Get ( csSid + BACK_SLASH + RUN_REG_PATH , _T("Malware Catcher 2009") , csData , HKEY_USERS ) )
		{			
			csFileNM = csData.Left( csData.ReverseFind('\"') );
			csFileNM.Replace(_T("\""),_T(""));
			csFileNM.Trim();
			
			if ( _taccess ( csFileNM , 0 ) != 0 )
				return ( false );
			
			if (! objFVI.DoTheVersionJob ( csFileNM , bToDelete ) )
				return ( false );

			csFolder = csFileNM.Left ( csFileNM.ReverseFind('\\') - 1);

			if ( m_objEnumProcess . IsProcessRunning ( csFileNM , bToDelete ) )
				SendScanStatusToUI ( Special_Process , m_ulSpyName , csFileNM );


			//SendScanStatusToUI ( Special_File , m_ulSpyName , csFullFileName  ) ;
			//SendMessageToUI ( m_csSpywareName , csFileNM , ENUM_WT_FILEWORM ) ;
			SendScanStatusToUI ( Special_File ,m_ulSpyName, csFileNM ) ;
			SendScanStatusToUI ( Special_RegVal , m_ulSpyName , HKU + (CString)BACK_SLASH + csSid + (CString)BACK_SLASH + (CString)RUN_REG_PATH + (CString)REG_SEPERATOR + _T("Malware Catcher 2009") ) ;
			SendScanStatusToUI ( Special_RegFix , m_ulSpyName , HKU + (CString)BACK_SLASH + csSid + (CString)BACK_SLASH + (CString)RUN_REG_PATH + REG_SEPERATOR + _T("Malware Catcher 2009") + REG_SEPERATOR + csData ) ;
			RemoveFolders ( csFolder , m_ulSpyName , bToDelete );
		}
		else
		{
			CheckByStartProgramsLink();
		}

		m_bSplSpyFound = bToDelete ? false : m_bSplSpyFound ;
		/*if ( m_bSplSpyFound ) 
			AddLogEntry ( _T("Spyware Found : %s") , m_csSpywareName ) ;*/

		return ( m_bSplSpyFound ) ;

	}
	
	catch(...)
	{
        CString csErr;
		csErr.Format( _T("Exception caught in CMalwareCatcherWorm::ScanSplSpy, Error : %d") ,GetLastError());
		AddLogEntry(csErr,0,0);
	}
	
	return ( false ) ;
}

/*-------------------------------------------------------------------------------------
	Function		: CheckByStartProgramsLink
	In Parameters	: void
	Out Parameters	: bool
	Purpose			: Check if the malware catcher lnk is present.
	Author			: Swtea Mulay
	Description		: Finds if the malware link file is present.
--------------------------------------------------------------------------------------*/
bool CMalwareCatcherWorm :: CheckByStartProgramsLink()
{
    CString csRegValue , csRegData ,csFileName;
    CPathExpander objPathExpander ;
    bool bSpywarePresent = false ;
    TCHAR szLinkTargetFileName [ MAX_PATH ] = { 0 } ;
    TCHAR szFullFileName [ MAX_PATH ] = { 0 } ;
    TCHAR szStartProgramsPath [ MAX_PATH ] = { 0 } ;
    TCHAR* pSlashPtr = NULL ;
    TCHAR* szLinkFileName[] =
    {
        _T("Malware Catcher 2009.lnk") ,
		_T("Malware Catcher.lnk") ,
        NULL
    } ;

    if ( ( _tcslen ( objPathExpander . m_CUPROFILE ) + _tcslen ( _T("\\Start Menu") ) + 1  >= _countof ( szStartProgramsPath ) ) )
        return ( false ) ;

    _tcscpy_s ( szStartProgramsPath , objPathExpander . m_CUPROFILE ) ;
    _tcscat_s ( szStartProgramsPath , _T("\\Start Menu") ) ;

    if ( _taccess ( szStartProgramsPath , 0 ) )
        return ( bSpywarePresent ) ;

    for ( short i = 0 ; szLinkFileName [ i ] ; i++ )
    {
        if ( _tcslen ( szStartProgramsPath ) + _tcslen ( szLinkFileName [ i ] ) + 2 >= _countof ( szFullFileName ) )
            continue ;

        memset ( szFullFileName , 0 , sizeof ( szFullFileName ) ) ;
        _tcscpy_s ( szFullFileName , szStartProgramsPath ) ;
        _tcscat_s ( szFullFileName , _T("\\") ) ;
        _tcscat_s ( szFullFileName , szLinkFileName [ i ] ) ;

        if ( _taccess ( szFullFileName , 0 ) )
            continue ;

		if ( !ResolveShortcut ( szFullFileName , szLinkTargetFileName , _countof ( szLinkTargetFileName ) ) )
            continue ;

		csFileName.Format(_T("%s"),szLinkTargetFileName);
		csFileName = csFileName.Left(csFileName.ReverseFind('\\'));
		SendScanStatusToUI ( Special_File , m_ulSpyName , szFullFileName );
		RemoveFolders (	csFileName , m_ulSpyName , false ) ;
    }

    return ( bSpywarePresent ) ;
}


/*-------------------------------------------------------------------------------------
	Function		: ResolveShortcut
	In Parameters	: LPCTSTR , LPTSTR , DWORD
	Out Parameters	: bool
	Purpose			: Resolve the lnk file
	Author			: Anand
	Description		: Find the actual path to the exe by resolving the link
--------------------------------------------------------------------------------------*/
bool CMalwareCatcherWorm :: ResolveShortcut ( LPCTSTR szShortcutFileName , LPTSTR szTargetFileName , DWORD cbTargetFileName )
{
    HRESULT hRes = E_FAIL;
    CComPtr<IShellLink> ipShellLink = NULL ;
    TCHAR szPath [ MAX_PATH ] = { 0 } ;
    TCHAR szDesc [ MAX_PATH ] = { 0 } ;
    WIN32_FIND_DATA wfd = { 0 } ;
    WCHAR wszTemp [ MAX_PATH ] = { 0 } ;

	// Removed Coinit as this is already done in AuScanner
	//HRESULT hr = CoInitialize(NULL);
	//COINITIALIZE_OUTPUTDEBUGSTRING(hr);

	// Get a pointer to the IShellLink interface
	hRes = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void**)&ipShellLink);
	COCREATE_OUTPUTDEBUGSTRING(hRes);
	if(FAILED(hRes))
	{
		//CoUninitialize();
		return false;
	}

    // Get a pointer to the IPersistFile interface
    CComQIPtr<IPersistFile> ipPersistFile ( ipShellLink ) ;

    // IMP: IPersistFile is using LPCOLESTR, so make sure that the string is Unicode
    // Open the shortcut file and initialize it from its contents
    hRes = ipPersistFile -> Load ( szShortcutFileName , STGM_READ ) ;
    if ( FAILED ( hRes ) )
    {
        //CoUninitialize() ;
        return ( false ) ;
    }

    /*
    INFO: This was commented because if the file was moved or renamed a mesage window appears
          which needs a user response. This mesage windows hangs the special spyware scanning
          as the message box has come from service and is not viewable to the user.
    // Try to find the target of a shortcut, even if it has been moved or renamed
    hRes = ipShellLink -> Resolve ( NULL , SLR_UPDATE ) ;
    if ( FAILED ( hRes ) ) 
    {
        CoUninitialize() ;
        return ( false ) ;
    }
    */

    // Get the path to the shortcut target
    hRes = ipShellLink -> GetPath ( szTargetFileName , cbTargetFileName , &wfd , SLGP_RAWPATH ) ;
    if ( FAILED ( hRes ) )
    {
        //CoUninitialize() ;
        return ( false ) ;
    }

    //CoUninitialize() ;
    return ( true ) ;
}

